# Design the Logical Model of Your Relational Database

### Relational Data Model
The _relational data model_ makes sure data is entered and/or updated in one place only, containing a number of linked tables that provide access to all data related to a particular record, or set of records.

_Entities_ are single items that can be described. They are generally written with a capital letter, and translate into database tables. An _entity instance_ is a single occurrence of an entity and equivalent to one record in the database._Entity types_ are collections of two or more tables with similar attribute that often describe very similar or related data.

### Primary and foreign keys
The _primary key_ is the attribute responsible for uniquely identifying a record in a table. The _foreign key_ is that same unique value, but in a different table (thus linking the two tables).

PKs are mostly numeric and often automatically generated by the DBMS when a new record is inserted.

## Database integry constraints

### Entity integrity
_Entity integrity_ defines the rules for primary key values. The primary key (and/or any component(s) that make it up) can't be null, and the DBMS will not allow any operation that produces a PK that violates this rule. 

### Referential integrity
_Referential integrity_ defines the rules for how foreign keys are maintained; the FK must reference an existing primary key or be `null`. The DBMS has rules to PK values from being changed without also changing the FK value that matches it. No **update** or **delete** operation can be performed on a primary key field if the foreign key value exists, and likewise an **insert** or **update** operation would be prevented if it'd result in a situation with no matching PK--this prevents _orphan records_. 

The only exception to these DBMS restrictions would be constraining a foreign key field to not contain `null`s.

## Database normalisation
One of the primary concepts of relational databases is maintaining a single source of truth, ie. storing, updating, and manipulating data in one place only. We normalise databases for two key reason:
1. To eliminate data redundancy
2. To ensure logical entities (ie. all related data is stored logically and together)

A non-normalised database could contain duplicate data in multiple locations, resulting in records with poor reliability and accuracy, giving us an inconsistent system no-one would want to use. Non-normalised tables also take up more storage space, and clutter existing tables with unnecessary table entries.

### First normal form (1NF)
1NF eliminates repeating groups, meaning that multi-valued attributes are removed. 1NF also establishes primary keys, thereby uniquely identifying records in a table.

1NF exists if these two criteria are met:
1. A primary key has been defined to uniquely identify records
2. There are no repeating groups in the relation

Or, from [Microsoft](https://support.microsoft.com/en-gb/help/283878/description-of-the-database-normalization-basics):
- Eliminate repeating groups in individual tables (ie. fields should contain atomic values only)
- Create a separate table for each set of related data.
- Identify each set of related data with a primary key.

**Movies (with repeating groups)**
| Title | Format |
| ----- | ----- |
| Alien | VHS, DVD |
| LotR  | VHS, DVD, BluRay |
| Godzilla | DVD, HD-DVD |

**Movies (1NF)**
| PK Id | Title | FK FormatId|
| ----- | ----- | ----- |
| 1 | Alien | 1 |
| 2 | Alien | 2 |
| 3 | LotR | 1 |
| 4 | LotR | 2 |
| 5 | LotR | 4 |
| 6 | Godzilla | 2 |
| 7 | Godzilla | 3 |

**Format (1NF)**
| PK Id | Format |
| ----- | ------ |
| 1     | VHS    |
| 2     | DVD    |
| 3     | HD-DVD |
| 4     | BluRay |


### Second normal form
2NF exists if these two criteria are met:
1. The relation is in 1NF
2. Partial dependencies are removed (ie., records should not depend on anything other than a table's primary key)

Again from [Microsoft](https://support.microsoft.com/en-gb/help/283878/description-of-the-database-normalization-basics):
- Create separate tables for sets of values that apply to multiple records.
- Relate these tables with a foreign key.

**Orders (with partial dependencies)**

| OrderId | OrderDate | CustomerId | LastName | Address | BookId | Title | Price |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |

Here, the book information (BookId, Title, Price) are only partially dependent on the primary key and could be associated with multiple orders.

**Orders (2NF)**

| OrderId | OrderDate | CustomerId | LastName | Address |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |

**Book (2NF)**
| BookId | Title | Price |
| ----- | ----- | ----- |

**BookOrderQuantity (2NF)**
| OrderId | BookId | Quantity |
| ----- | ----- | ----- |

(Note: Book and BookOrderQuantity can't be normalised further and are thus actually in 3NF.)

### Third normal form
3NF exists if these two criteria are met:
1. The relation is in 2NF
2. Transitive dependencies are removed (ie. values that are dependent not on the PK of the table, but rather on another field or fields)

And, yet again from [Microsoft](https://support.microsoft.com/en-gb/help/283878/description-of-the-database-normalization-basics): 
- Eliminate fields that do not depend on the key.

**Orders (with transitive dependencies)**
| OrderId | OrderDate | CustomerId | LastName | Address 
| ----- | ----- | ----- | ----- | ----- |


**Orders (3NF)**
| OrderId | OrderDate | CustomerId |
| ----- | ----- | ----- |


**Customers (3NF)**
| CustomerId | LastName | Address |
| ----- | ----- | ----- |